# 一、十几万条数据的渲染

requestAnimationFrame

DocumentFragment

# 二、为什么选择axios

- **jquery ajax：**

本身是针对MVC的编程,不符合现在前端MVVM的浪潮

基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案

JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受[CDN](https://cloud.tencent.com/product/cdn?from=10680)服务）

- **Fetch：**

符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里

更好更方便的写法

更加底层，提供的API丰富（request, response）

脱离了XHR，是ES规范里新的实现方式

1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理

2）fetch默认不会带cookie，需要添加配置项

3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费

4）fetch没有办法原生监测请求的进度，而XHR可以

Node版本node-fetch

- **Axios：**

从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作）

做[的XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)从浏览器

让[HTTP](http://nodejs.org/api/http.html)从node.js的请求

支持[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API

拦截请求和响应

转换请求和响应数据

取消请求

自动转换JSON数据

客户端支持防范[XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)

# 三、前后端联调方式

我的理解是前后端联调是一种真实业务数据和本地mock数据之间来回切换以达到前后端分离架构下的不同开发速度时数据交换的一种方式方法（有点绕）。

我认为需要联调的有以下两个方面的资源：

1、css、js、图片等前端静态资源文件。（和后端确认好后端数据的存放位置、根路径）

2、ajax获取的后端数据。

路径问题、域名解析

谷歌插件 **HostAdmin**

总结一下，**前后端联调**是一种**真实业务数据**和**本地****mock****数据**之间来回切换以达到前后端分离架构下的不同开发速度时数据交换的一种方式方法，而实现就是利用自动化构建工具的mock数据功能和修改域名解析文件hosts来实现的。

# 四、浏览器服务器的握手

1、TCP三次握手

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

2、TCP四次挥手

1.客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

2.服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

3.服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

4.客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

TCP为什么建立链接是三次，关闭链接是四次呢？

这是前端面试中在设计HTTP协议问题时，经常会被问的一个问题。其实也不难理解，因为服务端的listen状态下的socket当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

通过TCP协议使得两台设备成功链接，并成功发送了数据，接下来，就需要服务器端来处理数据了。

# 五、前端安全

web前端安全虽然在平时的开发中涉及的不是很多，但也是前端综合技能领域重要的一环。无论是对于提升产品整体的安全性可靠性，还是作为技术人员自身能力的提升，了解基本常见的前端安全问题，都是非常有必要的。

本文旨在对前端安全涉及的内容做一个梳理。其实作为讲解安全的文章，有一个痛点，那就是很难用文章的形式把这个具体的发生实现过程展示清楚，这可能需要大量的代码以及辅助的贴图，这样反而会让人看的迷糊。所以本文只会以文字形式讲解安全问题，以供大家对这个领域知识的梳理和回顾。

一、XSS(Cross-Site-Scripting)跨站脚本攻击

1.1 XSS攻击原理

XSS攻击的重点其实不在“跨站”这个字面上，重点是“脚本”。之所以这么说，是因为XSS攻击是发生在目标用户的浏览器层面的一种攻击，当用户浏览器渲染整个HTML文档的过程中出现了不被预期的脚本时，XSS就会发生。

其实XSS攻击攻击的原理还可以说的更加简单明了，就是用户访问的页面中，被植入了不安全的脚本。而这些脚本，具有各种危害用户的能力。至于这些脚本是如何被植入的，那形式就多种多样了。举几个例子。

1.很多网站内部的JavaScript代码，会读取浏览器地址中携带的信息，并作为内容在页面中展示。假如有这样一个URL地址

http://www.demo.com?xss=<script>alert(document.cookie)</script>

复制代码

这段地址中的query值xss如果被读取并且执行，就具备了在页面中执行程序的能力。这只是一个简单的alert，如果通过src的方式引入第三方JS文件，那么攻击者可做的事情就更多了。

escapeHTML()对&、<、>、”、’、/、进行转义

2.比较常见的是一些带有用户留言功能的网站。比如攻击者A在留言中写入了一段攻击代码，这段代被发送到服务器，并且没有经过转义过滤，。当用户B访问网页的时候，获取了这段代码并直接执行了，这就产生了XSS攻击。

总之，XSS的攻击者的目的就是想尽一切办法将他的脚本内容在目标网站中目标用户的浏览器上解析执行。

1.2 XSS攻击类型

XSS攻击根据类型可以分为:

1.反射型XSS(非持久型XSS)。XSS代码出现在URL中，攻击者需要将带有攻击脚本的URL发送给目标用户。用户点击访问后，在本地的浏览器解析执行了攻击代码。

2.存储型XSS(持久型XSS)。存储型的XSS代码，会被存储在服务器端。当用户访问网页的时候，从服务器拿到攻击代码并执行。

3.DOM XSS。它和其它两个类型的差别在于DOM XSS的XSS代码并不需要服务器解析响应的参与，触发XSS考的就是浏览器的DOM解析。

1.3 XSS攻击防御

说完了XSS的原理和类型，就得了解一下相关的解决防御方案。

**对于反射型XSS，需要注意的地方有：**

1.web页面渲染的内容必须从服务的获取，用户的输入必须经过处理才能展示。 2.不要从URL等这些途径获取数据直接展示到页面中。 3.对于用户输入，或者是动态获取的数据，需要经过转义才能执行展示。 **对于存储型XSS，需要注意的地方有：**

1.后端将数据存入数据库之前，先进行转义。

2.后端输出给前端的数据，需要进行统一转义处理。

3.前端获取后端的数据后，对数据进行转义处理。

二、CSRF(Cross-Site-Request-Forgery)跨站请求伪造

2.1 CSRF的原理和实现

CSRF的攻击有两个关键点:

1.跨站点的请求。

2.请求是伪造的。

我们知道，不同域的Ajax请求时不合法的，同源策略禁止了跨域的数据传输。那么不同站点的CSRF攻击是如何产生的呢？

这里有一个很重要的知识点就是，客户端HTML标签发出的跨域GET请求被认为是合法的，不在同源策略的限制中。

1.恶意网站B上有一个带有CSRF攻击代码的页面，其中的代码可能是这样

<img src="http://www.a.com/blog/del?id=5">

复制代码

2.攻击者诱使登录了正规A网站的用户，访问了他的B网站上的CSRF页面。

3.由于用户登录了A网站，所以访问这个页面请求了携带在img标签中的地址。并且在这个访问中，http中请求信息几乎是一模一样的。

通过这样的方式，攻击者不但绕开了同源策略的限制，还伪造了请求的身份信息。

2.2CSRF的防御

虽然CSRF的攻击能够伪造用户的信息，但是这样的请求毕竟是从第三方网站发起的，它并不会经过正规网站本身。所以对于CSRF的防御大概有 1.通过设置sameSite-Strict属性，禁止第三方网站携带cookie。 2.在正规网站的页面提交内容，可以设置验证码，或者是token。 3.虽然第三方网站的跨站请求信息几乎和正规网站是一样的，但是还是有所不同。这个不同就是请求信息中的Referer字段，这个字段描述了请求的来源。可以通过这个字段禁止第三方网站的请求。

三、界面操作劫持攻击

很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据。这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。

如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密--即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。

界面操作劫持攻击是一种基于视觉欺骗的web会话攻击，它通过在页面可见控件上覆盖一个不可见的框(iframe)，使得用户误以为自己在操作可见框，从而在用户不知情的情况下篡改数据、窃取信息等。

界面劫持攻击大概有三类:

1.点击劫持。

2.拖放劫持。

3.触屏劫持。

界面操作劫持的防御主要在于禁止网站被嵌入到iframe中，可以通过JavaScript代码实现。也可以通过X-FRAME-OPTIONS属性的设置，禁止页面被嵌入到iframe中。

四、Cookie安全问题

cookie是一种前端数据存储方式，后端通过HTTP响应头设置cookie。很多攻击的实现，都是通过获取用户的cookie信息，从而伪造身份造成攻击。所以保证cookie的安全，是前端安全的重要一环。

cookie的安全可以从以下几个方面着手。

1.通过加签名的方式，防止cookie被篡改。

2.通过对cookie内容的加密，防止被盗用。

3.设置响应头中的http-only字段，方式客户端的JavaScript代码读取cookie。

4.设置secure字段，只允许在https下使用cookie。

5.通过same-site保证cookie安全(浏览器兼容性较差)。

关于前端安全的问题，各式各样的变形还有很多。攻击往往也不是单一的方式，而是多种多样的攻击手段的组合。为了保证前端页面的安全性和可靠性，需要前后端的通力合作。

# 六、一个操作Dom动画卡顿原因

1、动画卡顿的原因：

大多数设备的刷新频率是60次/秒，也就是1秒钟的动画是由60个画面连在一起生成的，所以要求浏览器对每一帧画面的渲染工作要在16ms内完成。当渲染时间超出16ms时，1秒钟内少于60个画面生成，就会有不连贯、卡顿的感觉，影响用户体验。

2、页面渲染流程

  JavaScript：JavaScript实现动画效果，DOM操作等。 

  Style（样式计算）：确认每个DOM元素应用的CSS样式规则。 

  Layout（布局）：计算每个DOM元素最终在屏幕上的大小和位置。由于DOM元素的布局是相对的，所以当某个元素发生变化影响了布局时，其他元素也会随之变化，则需要回退重新渲染，这个过程称之为reflow。 

  Paint（绘制）：在多个层上绘制DOM元素的文字、颜色、图像、边框和阴影等。 

  Composite（Render Layer合并）：按照合理的顺序合并图层并显示到屏幕上。 浏览器在实际渲染页面的时候需要经过一系列的映射，由HTML页面构建出来的DOM树到最终的图层，映射过程如下图(来源：[参考[3\]](#3))所示（注意下图类名在后续有所更改，RenderObject->LayoutObject，RenderLayer->PaintLayer）：

​                                                  

**Node->RenderObject**：DOM树的每个Node都有一个对应的RenderObject（一对一关系，RenderObject包含了Node的内容）；

**RenderObject -> RenderLayer**：一个或多个RenderObject对应一个RenderLayer（多对一），RenderLayer用于保证元素之间的层级关系，一般来说位于同一位置的且层级相同的元素位于同一个Render Layer，只有某些特殊的RenderObject会专门创建一个新的渲染层，其他的RenderObject与第一个拥有RenderLayer的祖先元素共用一个。常见的生成RenderLayer的RenderObject拥有以下的一种特征[参考[3\]](#3)：

  页面根元素 

  有CSS定位属性（relative, absolute, fixed, sticky） 

  transparent不为1 

  overflow不为visible 

  有CSS mask属性 

  有CSS box-reflect属性 

  有CSS filter属性 

  3D或硬件加速的2D canvas元素 

  video元素

RenderLayer -> GraphicsLayer：一个或多个RenderLayer对应一个GraphicsLayer（多对一），某些被认为是Compositing Layer的RenderLayer单独对应一个GraphicsLayer，其他RenderLayer与第一个拥有GraphicsLayer的祖先元素共用一个GraphicsLayer。每个GraphicsLayer有一个GraphicsContext用于绘制其对应的RenderLayers，合成器将GraphicsContexts的位图合成，最终显示到屏幕上。渲染层提升为合成层的原因如下：

有3D transform属性

有perspective属性

3D canvas或硬件加速的2D canvas

硬件加速的iframe元素（如iframe嵌入的页面有合成层，合成层需要硬件加速）

使用了硬件加速的插件，如flash

对opacity/transform属性应用了animation/transition（当animation/transition为active）

子元素是compositing layer

兄弟元素是compositing layer，与当前的非composting layer有重叠，层级低于当前层

有will-change属性

3、优化方法

结合页面渲染流程，这里将结合一些测试代码，分析动画的各种优化方案和效果：

JavaScript：优化JavaScript的执行效率 

requestAnimationFrame代替setTimeout和setInterval

可并行的DOM元素更新划分为多个小任务

DOM无关的耗时操作放到Web Workers中

Style：降低样式计算复杂度和范围 

降低样式选择器的复杂度

减少需要执行样式计算的元素个数

Layout：避免大规模、复杂的布局 

避免频繁改变布局

用flexbox布局替代老的布局模型

避免强制同步布局事件

Paint/Composite：GPU加速 

将移动或渐变元素由渲染层（RenderLayer）提升为合成层（Compositing Layer）

避免提升合成层的陷阱

# 七、回流、重绘

1、浏览器渲染原理

   

浏览器向服务器请求到了HTML文档后便开始解析，产物是DOM（文档对象模型），如果有css，会根据css生成CSSOM（CSS对象模型），然后再由DOM和CSSOM合并产生渲染树，有了渲染树，知道了所有节点的样式，便根据这些节点以及样式计算它们在浏览器中确切的大小和位置，这就是布局。最后把节点绘制到浏览器上。

css的加载和解析不会阻塞html文档的解析

css的解析会阻塞js的执行，必须等到CSSOM生成后才能执行js

js的执行会阻塞html文档的解析

html一边解析一边显示

css必须完全解析完毕才能进入生成渲染树环节

创建DOM树—创建CSSOM树—执行脚本—生成渲染树—生成布局—绘制

2、重绘

当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），浏览器只会将新样式赋予元素并进行重新绘制操作。

3、回流 reflow

当改变的操作响应文档内容或者结构，或者元素位置时，就会触发回流。有以下几种情况：

DOM操作（对元素的增删改、顺序变化等）

内容变化，包括表单区域内的文本变化

css属性的更改或者重新计算

增删样式表内容

修改class属性

浏览器窗口变化（滚动或缩放）

伪类样式激活（：hover等）

4、浏览器优化渲染

浏览器本身能够进行优化，尽可能减少重绘和回流。 

一个position为absolute或fixed的元素更改，只会影响本身及子元素，而static元素则会影响后面所有元素。 

JavaScript执行时，浏览器会缓存所有变化，然后一次性全部绘制。（读取元素属性会引起强制回流）。

我们可以进行的优化： 

样式表放在head标签中，脚本放在body结束前。 

简化并优化css选择器。（选择器是从右到左匹配） 

避免触发同步布局事件

对于复杂动画效果,使用绝对定位让其脱离文档流

DOM节点保存在一个变量中，避免重复获取。（合并多次对DOM和样式的修改，然后依次处理掉）

修改元素样式时，更改其class属性更好。

# 八、Vue双向绑定机制

Vue.js采用ES5提供的属性特性功能，结合发布者-订阅者模式，通过Object.defineProperty()为各二个属性定义get、set特性方法，在数发生改变时给订阅者发布消息，触发相应的监听回调

具体步骤如下

（1）对需要观察的数据对象进行递归遍历，包括子属性对象的属性，设置set和get特性方法。当给这个对象的某个值赋值时，会触发绑定的set特性方法，于是就能监听到数据变化。

（2）用compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化，就会收到通知吗，并更新视图

（3）Wathcer订阅者是Oberver和Compile之间通信的桥梁，主要功能如下：

在自身实例化时向属性订阅器Dep里面添加自己。

自身必须有一个Update()方法

在dep.notice()发布通知时，能调用自身的update()方法，并触发Compile中绑定的回调函数

（4）MVVM是数据绑定的入口，整合了Observer、Compile和Watcher三者，通过Oberver来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭建Oberver和Compile之间的通信桥梁，达到数据变化通知视图更新的效果，利用视图交互，变化更新数据model变更的双向绑定的效果

# 九、闭包

可以作为一种数据缓存

《JavaScript高级程序设计》这样描述：闭包是指有权访问另一个函数作用域中的变量的函数；

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部

闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。

通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。

# 十、手写数组乱序

 

   

   

 

 

# 十一、diff 算法

diff算法做的事情是比较VNode和oldVNode，再以VNode为标准的情况下在oldVNode上做小的改动，完成VNode对应的Dom渲染。

 

实现步骤：

用JavaScript对象模拟DOM

把此虚拟DOM转成真实DOM并插入页面中

如果有事件发生修改了虚拟DOM

比较两棵虚拟DOM树的差异，得到差异对象

把差异对象应用到真正的DOM树上

 

DOM DIFF

比较两棵DOM树的差异是Virtual DOM算法最核心的部分.简单的说就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染。借网络一张图片说明:

   

**比较只会在同层级进行, 不会跨层级比较。**

比较后会出现四种情况：

1、此节点是否被移除 -> 添加新的节点 

2、属性是否被改变 -> 旧属性改为新属性

3、文本内容被改变-> 旧内容改为新内容

4、节点要被整个替换 -> 结构完全不相同 移除整个替换

 

其中有个需要注意的是新旧虚拟dom比较的时候，是先同层比较，同层比较完看看是否有儿子，有则需要继续比较下去，直到没有儿子。搞个简单的图来说明一下吧：

同层比较，比较顺序是上面的数字来，把不同的打上标记，放到数组里面去，统一交给patch处理。

 

# 十二、事件队列

JavaScript一大特点就是单线程，一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。但浏览器是多线程的。

阮一峰老师总结的任务分为两种，一种是同步任务，另一种是异步任务，同步任务指的是，在主线程上排队执行的任务，只有当前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入任务队列的任务，只有任务队列通知主线程，某个异步操作可以执行了，该任务才会进入主线程执行。

（1）所有同步任务都在主线程上执行，形成一个[执行栈](http://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

 

任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。

1、宏任务

setTimeout、setInterval、I/O

script代码块

2、微任务

nextTick、callback、Promise、process.nextTick、Object.observe、MutationObserver

 

事件循环的顺序，决定js代码的执行顺序。一段代码块就是一个宏任务。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

为什么setTimeout里面的代码到了最后才执行，原因就是，js的执行是单线程的。而当它遇到了window的setTimeout和setInterval这样的异步任务，js都默默地先不执行这些回调，而是继续向下执行其他js脚本，等到所有js脚本都解析执行完了，再执行回调。

那么有多个回调的时候执行顺序是怎么样的呢？浏览器是多线程的，js执行线程只是它多个线程中的一个。当js的执行线程看到了setTimeout，浏览器马上会调用其他线程把这个函数中的回调扔到浏览器的事件队列中，事件队列是先入先出的队列。那么在js执行线程执行完所有脚本空闲的时候，事件队列中的事件回调，会一个一个被拿出来执行。浏览器有一个内部大消息循环Event Loop（事件循环），会轮询事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：input onchange），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了才能执行下一个。

# 十三、防抖、节流

 - 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。

1. 有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。

- 节流：指定时间间隔内只会执行一次任务。

1. 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。
2. 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。

# 十四、Vuex原理解析

Vuex是专门为Vue服务，用于管理页面的数据状态、提供统一数据操作的生态系统，相当于数据库mongoDB，MySQL等，任何组件都可以存取仓库中的数据。

Vuex采用MVC模式中的Model层，规定所有的数据必须通过action--->mutaion--->state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过DEVtools去查看状态。

在当前前端的spa模块化项目中不可避免的是某些变量需要在全局范围内引用，此时父子组件的传值，子父组件间的传值，兄弟组件间的传值成了我们需要解决的问题。虽然vue中提供了props（父传子）commit（子传父）兄弟间也可以用localstorage和sessionstorage。但是这种方式在项目开发中带来的问题比他解决的问题（难管理，难维护，代码复杂，安全性低）更多。vuex的诞生也是为了解决这些问题，从而大大提高我们vue项目的开发效率。

视图通过点击事件，触发mutations中方法，可以更改state中的数据，一旦state数据发生更改，getters把数据反映到视图。

那么actions,可以理解处理异步，而单纯多加的一层。

既然提到了mutions actions这时候 就不得不提**commit，dispatch**这两个有什么作用呢？

在vue例子中，通过click事件，触发methods中的方法。当存在异步时，而在vuex中需要dispatch来触发actions中的方法，actions中的commit可以触发mutations中的方法。同步，则直接在组件中commit触发vuex中mutations中的方法。

**问题1：**使用Vuex只需执行 Vue.use(Vuex)，并在Vue的配置中传入一个store对象的示例，store是如何实现注入的？

可见，store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期 钩子 beforeCreate 完成的。即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。

**问题2：vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？**

new vue实现双向数据绑定，只有data中的数据才是响应式

我们可以看出Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。

**1、vuex有哪几种属性？**

有五种，分别是 State、 Getter、Mutation 、Action、 Module

**2、vuex的State特性是？**

一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data

二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新

三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

**3、vuex的Getter特性是？**

一、getters 可以对State进行计算操作，它就是Store的计算属性

二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用

三、 如果一个状态只在一个组件内使用，是可以不用getters

**4、vuex的Mutation特性是？**

一、Action 类似于 mutation，不同在于：

二、Action 提交的是 mutation，而不是直接变更状态。

三、Action 可以包含任意异步操作

**5、Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？**

一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。

二、如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。

**6、不用Vuex会带来什么问题？**

一、可维护性会下降，你要想修改数据，你得维护三个地方

二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的

三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。

# 十五、冒泡、快排，复杂度

 

 

 

# 十六、GET、POST区别

最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

- GET和POST是什么？

HTTP协议中的两种发送请求的方法。

- HTTP是什么？

HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。

- GET和POST还有一个重大区别，简单的说：

GET产生一个TCP数据包；POST产生两个TCP数据包。

长的说：

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

- 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

1. GET与POST都有自己的语义，不能随便混用。

2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。

3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

 

# 十六、call、apply、bind

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 